# Use Gitops Delivery with Carvel App (alpha)

This topic explains how to deliver Carvel `Packages`, created by the Carvel Package Supply Chains, from a GitOps repository to one or more run clusters using Carvel App.

## Prerequisites

To use Gitops Delivery with Carvel App, you must complete the following prerequisites:

- You must create a `Workload` that uses the Carvel Package Supply Chains. See the [documentation](./carvel-package-supply-chain.hbs.md). You must have at least one Carvel `Package` generated by this `Workload` stored in your GitOps repository.
- You must have at least one Run cluster. Run clusters serve as your deployment environments. They can either be Tanzu Application Platform clusters, or regular Kubernetes clusters, but they must have kapp-controller and Contour installed. See the [Carvel documentation](https://carvel.dev/kapp-controller/) and the [Contour documentation](https://projectcontour.io/).
- You must create a Build cluster that has network access to your Run clusters.

## Set up Run Cluster Namespaces

Each Run cluster must have a namespace and `ServiceAccount` with the correct permissions to deploy the Carvel `Packages`.

If your Run cluster is also a Tanzu Application Platform cluster, see the [documentation](../set-up-namespaces.hbs.md) to set up a developer namespace.

If your Run cluster is not a Tanzu Application Platform cluster, create a namespace and `ServiceAccount` with the following permissions:

```yaml
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: <run-cluster-ns>
  name: app-cr-role
rules:
- apiGroups: ["apps"]
  resources: ["deployments"]
  verbs: ["get", "list", "create", "update", "delete"]
- apiGroups: [""]
  resources: ["configmaps", "services"]
  verbs: ["get", "list", "create", "update", "delete"]
- apiGroups: ["networking.k8s.io"]
  resources: ["ingresses"]
  verbs: ["get", "list", "create", "update", "delete"]
```

## Create Carvel PackageInstalls and Secrets

For each Carvel `Package`, for each Run cluster, you must create a Carvel `PackageInstall` and a `Secret`. The Carvel `PackageInstall` and the `Secret` will be stored in your GitOps repository and deployed to Run clusters by the Carvel `App`.

Here is an example GitOps repository structure after completing this section:

```console
app.default.tap/
  packages/
    20230321004057.0.0.yaml  # Package
  staging/
    packageinstall.yaml      # PackageInstall
    params.yaml              # Secret
  prod/
    packageinstall.yaml      # PackageInstall
    params.yaml              # Secret
```

1. For each Run cluster, create a `Secret` that has the values for each `Package` parameter. You can see the configurable properties of the `Package` by inspecting the `Package` CRâ€™s valuesSchema, or in the Carvel Package Supply Chains [documentation](./carvel-package-supply-chain.hbs.md). Store the `Secret` in your GitOps repository at `<package_name>/<run_cluster>/params.yaml`.

   ```yaml
   ---
   apiVersion: v1
   kind: Secret
   metadata:
     name: app-values
   stringData:
     values.yaml: |
       ---
       replicas: 2
       hostname: app.mycompany.com
   ```

   > **Note:** You can skip this step if you want to use the default parameter values.

2. For each Run cluster, create a `PackageInstall`. Reference the `Secret` you created in the previous step. Store the `PackageInstall` in your GitOps repository at `<package_name>/<run_cluster>/packageinstall.yaml`.

   ```yaml
   ---
   apiVersion: packaging.carvel.dev/v1alpha1
   kind: PackageInstall
   metadata:
     name: app
   spec:
     serviceAccountName: <run-cluster-ns-sa> # ServiceAccount on Run cluster with permissions to deploy Package, see "Set up Run Cluster Namespaces"
     packageRef:
       refName: app.default.tap # name of the Package
       versionSelection:
         constraints: 20230321004057.0.0 # version of the Package
     values:
     - secretRef:
         name: app-values # Secret created in previous step
   ```

   > **Note:** If you want to continously deploy the latest version of your `Package`, you can set `versionSelection.constraints: >=0.0.0`
   > **Note:** If you skipped creation of the `Secret`, omit the `values` key.

3. Push the newly created `PackageInstalls` and `Secrets` to your GitOps repository.

## Create App

1. You need to give the Build cluster access to the Run clusters. On the Build cluster, for each Run cluster, create a `Secret` containing the Run cluster's kubeconfig:

   ```console
   kubectl create secret generic <run-cluster>-kubeconfig \
       -n <build-cluster-ns> \
       --from-file=value.yaml=<path-to-run-cluster-kubeconfig>
   ```

2. The Carvel `App` custom resource represents a collection of Kubernetes resources that kapp-controller can fetch and deploy to a cluster. The `App` will be pointed at the git repository branch where kapp-controller resources (e.g. `PackageRepository` and `Packages`) will be defined. By default, an `App` custom resource will sync the cluster with its fetch source every 30 seconds to prevent the cluster state from drifting from its source of truth, which is a git repository in this case. Create the following `App` on your Build cluster:

   ```yaml
   ---
   apiVersion: kappctrl.k14s.io/v1alpha1
   kind: App
   metadata:
     name: hello-app-app
     namespace: <build-cluster-ns>
   spec:
     # specifies that app should be deployed authenticated via the
     # given service account, found in this namespace
     serviceAccountName: <SERVICE_ACCOUNT>
     # specifies that app should be deployed to destination cluster;
     # by default, cluster is same as where this resource resides
     cluster:
       # specifies namespace in destination cluster
       namespace: ns2
       # specifies secret containing kubeconfig
       kubeconfigSecretRef:
         # specifies secret name within app's namespace
         name: cluster1
         # specifies key that contains kubeconfig
         key: value
     fetch:
     - git:
         url: # GitOps repo URL ex: https://github.com/mycompany/my-gitops
         ref: # GitOps repo branchex: origin/main
         subPath: <path_for_packages> # ex: hello-app.dev.tap/packages/
     - git:
         url: # GitOps repo URL ex: https://github.com/mycompany/my-gitops
         ref: # GitOps repo branch ex: origin/main
         subPath: <path_for_package_installs> # ex: hello-app.dev.tap/runcluster1
     template:
     - ytt: {}

      deploy:
     - kapp:
         intoNs: <DESIRED_NAMESPACE>
         rawOptions: ["--dangerous-allow-empty-list-of-resources=true"]
   ```

   > **Note:** The fetch section can includes entries for all the locations in the gitops repo to be deployed, and be appended with other run clusters if needed. Each App CR must specify either a service account (via `spec.serviceAccountName`) or, a `Secret` with kubeconfig contents for some Run cluster (via `spec.cluster.kubeconfigSecretRef.name`).

3. You will also need to create a `ServiceAccount` with associated RBAC permissions for the App to use. Example of the required permissions for the `ServiceAccount`. Make sure to assess appropriate RBAC needed for your specific PackageInstalls.

   ```yaml
   apiVersion: v1
   kind: ServiceAccount
   metadata:
     name: pkg-gitops-pkgi-sa
     namespace: <DESIRED_NAMESPACE>
     annotations:
       kapp.k14s.io/change-group: "packageinstall-setup"
   # secrets can be added if accessing private repositories or repos
   ---
   kind: Role
   apiVersion: rbac.authorization.k8s.io/v1
   metadata:
     name: pkg-gitops-pkgi-role
     namespace: <DESIRED_NAMESPACE>
     annotations:
       kapp.k14s.io/change-group: "packageinstall-setup"
   rules:
   - apiGroups: ["*"]
     resources: ["*"]
     verbs: ["*"]
   ---
   kind: RoleBinding
   apiVersion: rbac.authorization.k8s.io/v1
   metadata:
     name: pkg-gitops-pkgi-role-binding
     namespace: <DESIRED_NAMESPACE>
     annotations:
       kapp.k14s.io/change-group: "packageinstall-setup"
   subjects:
   - kind: ServiceAccount
     name: pkg-gitops-pkgi-sa
     namespace: <DESIRED_NAMESPACE>
   roleRef:
     apiGroup: rbac.authorization.k8s.io
     kind: Role
     name: pkg-gitops-pkgi-role
   ```

## Verifying Applications

To verify your installation:

1. Target a Run cluster. Confirm that all Packages from the GitOps repository are deployed:

   ```console
   kubectl get packages -A
   ```

2. Target a Run cluster. Confirm that all PackageInstalls are reconciled:

   ```console
   kubectl get packageinstalls -A
   ```

Now you can access your application on each Run cluster.